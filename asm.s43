#include "msp430.h"                     ; #define controlled include file
        
        NAME    main                    ; module name

        PUBLIC  main, highBytes, lowBytes           ; make the main label vissible
                                        ; outside this module
        
        
        
        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT_1_ISR                    ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

       
        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine
        

        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     01C00H
state   db      0
        align   1
        
// High Bytes and low bytes for numbers
//              0      1    2      3    4     5     6     7     8     9
highBytes  db  0xFC, 0x60, 0xDB, 0xF1, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xF7  ; High Bytes for Numbers     
lowBytes   db  0x28, 0, 0, 0, 0, 0, 0, 0, 0, 0 ; Low Bytes for Numbers
ticks     DW 0                    ; TIMER_A0 interrupts counter


        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment



; IO
EXTERN S1InterruptWithCallback, S2InterruptWithCallback, activateLed1, deactivateLed1
; Timer
EXTERN stopTimer, startTimer
; Drawing
EXTERN displayLog, displayOption, displayRead, displayClock
; Setup
EXTERN SetupLCD,  SetupPins, UnlockGPIO, SetupInterruptsS1, SetupInterruptsS2, SetupTimer
; transitionHandling
EXTERN handleTransitionS1, handleTransitionS2, handleTransitionTick

init:   MOV     #SFE(CSTACK), SP        ; set up stack
        
        bic.b   #00000001b, &P1OUT      ; Turn off red and green LEDs
        bic.b   #10000000b, &P9OUT
        
        call #SetupPins
        call #UnlockGPIO
        call #SetupLCD
        call #SetupInterruptsS1
        call #SetupInterruptsS2
        call #SetupTimer
        
        mov.b #0, state
        mov     #0, ticks         ; Clear intsCounter
        call #displayOption
        
        bic.b   #0xFF, &P1IFG           ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.
        NOP
      
        bis     #GIE, SR           ; Enable interrupts and enter Low Power mode 0
                                        ; that doesn't disable timers
        NOP                             ; Required after enabling interrupts

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        
        

        jmp main
        
PORT_1_ISR:
    bic.b   #06h, &P1IE             ; Disable interrupt at P1.1, P1.2
    push R5
    push R6
   
    mov #state, R6
    mov #handleTransitionS2, R5
    call #S2InterruptWithCallback
    
    mov #handleTransitionS1, R5
    call #S1InterruptWithCallback
    
    bic.b   #0xFF, &P1IFG
    
    pop R6
    pop R5
    bis.b   #06h, &P1IE ; Enable interrupts at P1.1, P1.2
    reti

TIMER_A0_ISR: ;After every interrupt increase the intsCounter
    push r5
    push r6
    
    xor.b #BIT0,&P1OUT            ; Toggle P1.0 (Red LED)
    inc ticks
    
    mov #ticks, r5
    mov #state, r6
    
    call #handleTransitionTick
    
    cmp #150, ticks
    jeq FINISH_TIMER
    
RETI_TIMER:
    pop r6
    pop r5
    reti
    
FINISH_TIMER:
    call #stopTimer
    mov #12, state
    call #displayClock
    mov #0, ticks
    jmp RETI_TIMER
// ----------------------------------------------------------------------------


final:
        JMP $                           ; jump to current location '$'
        
        NOP                             ; (endless loop)
        END